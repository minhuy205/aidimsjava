package com.aidims.aidimsbackend.service;
import com.aidims.aidimsbackend.dto.ImageAnalysisRequest;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import java.time.Duration;
import java.util.*;

@Service
public class ChatService {
    public String testGeminiDirectly(String message) {
        if (geminiApiKey == null || geminiApiKey.trim().isEmpty() ||
                geminiApiKey.equals("YOUR_GEMINI_API_KEY_HERE")) {
            throw new RuntimeException("Gemini API key ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh");
        }

        try {
            Map<String, Object> requestBody = createGeminiRequestBody("Test: " + message);

            String response = webClient.post()
                    .uri(geminiApiUrl + "?key=" + geminiApiKey)
                    .header("Content-Type", "application/json")
                    .bodyValue(requestBody)
                    .retrieve()
                    .bodyToMono(String.class)
                    .timeout(Duration.ofSeconds(30))
                    .block();

            JsonNode jsonResponse = objectMapper.readTree(response);

            if (jsonResponse.has("candidates") &&
                    jsonResponse.get("candidates").size() > 0) {

                JsonNode candidate = jsonResponse.get("candidates").get(0);
                if (candidate.has("content") &&
                        candidate.get("content").has("parts") &&
                        candidate.get("content").get("parts").size() > 0) {

                    return candidate.get("content").get("parts").get(0).get("text").asText();
                }
            }

            throw new RuntimeException("Invalid response format: " + response);

        } catch (Exception e) {
            throw new RuntimeException("Gemini API test failed: " + e.getMessage());
        }
    }

    public String testOpenAIDirectly(String message) {
        // Implement t∆∞∆°ng t·ª± cho OpenAI n·∫øu c·∫ßn
        return "OpenAI test placeholder";
    }
    @Value("${gemini.api.key:}")
    private String geminiApiKey;

    @Value("${gemini.api.url:https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent}")
    private String geminiApiUrl;

    @Value("${openai.api.key:}")
    private String openaiApiKey;
    @Value("${gemini.vision.api.url:https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent}")
    private String geminiVisionApiUrl;
    private final WebClient webClient;
    private final ObjectMapper objectMapper;
    private final Map<String, String> symptomDiagnosis;
    private final Map<String, String> dicomFindings;

    public ChatService() {
        this.webClient = WebClient.builder()
                .build();
        this.objectMapper = new ObjectMapper();
        this.symptomDiagnosis = initializeSymptomDiagnosis();
        this.dicomFindings = initializeDicomFindings();
    }

    public String getChatResponse(String message) {
        return getChatResponse(message, "default");
    }

    public String getChatResponse(String message, String sessionId) {
        // ∆Øu ti√™n s·ª≠ d·ª•ng Gemini API
        if (geminiApiKey != null && !geminiApiKey.trim().isEmpty() &&
                !geminiApiKey.equals("YOUR_GEMINI_API_KEY_HERE")) {
            try {
                return getGeminiResponse(message);
            } catch (Exception e) {
                System.err.println("Gemini API failed: " + e.getMessage());
                // Fallback to OpenAI if Gemini fails
                return tryOpenAIOrFallback(message);
            }
        }

        // Fallback to OpenAI ho·∫∑c local logic
        return tryOpenAIOrFallback(message);
    }

    private String getGeminiResponse(String message) {
        try {
            // T·∫°o system prompt cho y t·∫ø
            String medicalPrompt = createMedicalPrompt(message);

            // T·∫°o request body theo format Gemini API
            Map<String, Object> requestBody = createGeminiRequestBody(medicalPrompt);

            // G·ªçi Gemini API
            String response = webClient.post()
                    .uri(geminiApiUrl + "?key=" + geminiApiKey)
                    .header("Content-Type", "application/json")
                    .bodyValue(requestBody)
                    .retrieve()
                    .bodyToMono(String.class)
                    .timeout(Duration.ofSeconds(30))
                    .block();

            // Parse response
            JsonNode jsonResponse = objectMapper.readTree(response);

            if (jsonResponse.has("candidates") &&
                    jsonResponse.get("candidates").size() > 0) {

                JsonNode candidate = jsonResponse.get("candidates").get(0);
                if (candidate.has("content") &&
                        candidate.get("content").has("parts") &&
                        candidate.get("content").get("parts").size() > 0) {

                    String aiResponse = candidate.get("content").get("parts").get(0).get("text").asText();
                    return formatMedicalResponse(aiResponse);
                }
            }

            throw new RuntimeException("Invalid response format from Gemini");

        } catch (WebClientResponseException e) {
            throw new RuntimeException("Gemini API Error: " + e.getStatusCode() + " - " + e.getResponseBodyAsString());
        } catch (Exception e) {
            throw new RuntimeException("Gemini API Error: " + e.getMessage());
        }
    }

    private Map<String, Object> createGeminiRequestBody(String prompt) {
        Map<String, Object> requestBody = new HashMap<>();

        // T·∫°o parts
        Map<String, Object> part = new HashMap<>();
        part.put("text", prompt);

        // T·∫°o content
        Map<String, Object> content = new HashMap<>();
        content.put("parts", Arrays.asList(part));

        // T·∫°o contents array
        requestBody.put("contents", Arrays.asList(content));

        // C·∫•u h√¨nh generation
        Map<String, Object> generationConfig = new HashMap<>();
        generationConfig.put("temperature", 0.3);
        generationConfig.put("topK", 40);
        generationConfig.put("topP", 0.95);
        generationConfig.put("maxOutputTokens", 1024);

        requestBody.put("generationConfig", generationConfig);

        // Safety settings ƒë·ªÉ tr√°nh b·ªã block
        List<Map<String, Object>> safetySettings = new ArrayList<>();
        String[] categories = {
                "HARM_CATEGORY_HARASSMENT",
                "HARM_CATEGORY_HATE_SPEECH",
                "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "HARM_CATEGORY_DANGEROUS_CONTENT"
        };

        for (String category : categories) {
            Map<String, Object> safety = new HashMap<>();
            safety.put("category", category);
            safety.put("threshold", "BLOCK_ONLY_HIGH");
            safetySettings.add(safety);
        }

        requestBody.put("safetySettings", safetySettings);

        return requestBody;
    }

    private String createMedicalPrompt(String userMessage) {
        return "B·∫°n l√† AI chuy√™n khoa y t·∫ø c·ªßa b·ªánh vi·ªán AIDIMS, h·ªó tr·ª£ b√°c sƒ© ph√¢n t√≠ch tri·ªáu ch·ª©ng.\n\n" +
                "NHI·ªÜM V·ª§:\n" +
                "- Ph√¢n t√≠ch tri·ªáu ch·ª©ng b·ªánh nh√¢n\n" +
                "- ƒê∆∞a ra ch·∫©n ƒëo√°n ph√¢n bi·ªát (top 3-5)\n" +
                "- ƒê·ªÅ xu·∫•t x√©t nghi·ªám c·∫ßn thi·∫øt\n" +
                "- ƒê√°nh gi√° m·ª©c ƒë·ªô ∆∞u ti√™n\n" +
                "- Gi·∫£i th√≠ch DICOM findings n·∫øu c√≥\n\n" +

                "ƒê·ªäNH D·∫†NG TR·∫¢ L·ªúI:\n" +
                "ü©∫ **PH√ÇN T√çCH TRI·ªÜU CH·ª®NG**\n" +
                "- M√¥ t·∫£ ng·∫Øn g·ªçn\n\n" +

                "üîç **CH·∫®N ƒêO√ÅN PH√ÇN BI·ªÜT:**\n" +
                "1. [Ch·∫©n ƒëo√°n ch√≠nh] - [x√°c su·∫•t %]\n" +
                "2. [Ch·∫©n ƒëo√°n 2] - [x√°c su·∫•t %]\n" +
                "3. [Ch·∫©n ƒëo√°n 3] - [x√°c su·∫•t %]\n\n" +

                "üìä **X√âT NGHI·ªÜM ƒê·ªÄ XU·∫§T:**\n" +
                "- C·∫≠n l√¢m s√†ng: [...]\n" +
                "- H√¨nh ·∫£nh: [...]\n" +
                "- Kh√°c: [...]\n\n" +

                "‚ö° **M·ª®C ƒê·ªò ∆ØU TI√äN:**\n" +
                "üî¥ Kh·∫©n c·∫•p / üü° Theo d√µi / üü¢ Th·∫•p\n\n" +

                "üíä **ƒêI·ªÄU TR·ªä BAN ƒê·∫¶U:**\n" +
                "- Tri·ªáu ch·ª©ng: [...]\n" +
                "- Theo d√µi: [...]\n\n" +

                "L∆ØU √ù:\n" +
                "- Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát\n" +
                "- Ng·∫Øn g·ªçn, d·ªÖ hi·ªÉu\n" +
                "- T·ªëi ƒëa 300 t·ª´\n" +
                "- S·ª≠ d·ª•ng emoji v√† format markdown\n\n" +

                "TRI·ªÜU CH·ª®NG/C√ÇU H·ªéI C·ª¶A B·ªÜNH NH√ÇN:\n" + userMessage;
    }

    private String formatMedicalResponse(String response) {
        // Th√™m th√¥ng tin b·ªï sung cho response
        StringBuilder formatted = new StringBuilder();
        formatted.append(response);

        // Th√™m disclaimer
        formatted.append("\n\n---\n");
        formatted.append("‚ö†Ô∏è **L∆ØU √ù:** ƒê√¢y ch·ªâ l√† t∆∞ v·∫•n h·ªó tr·ª£. ");
        formatted.append("Quy·∫øt ƒë·ªãnh cu·ªëi c√πng thu·ªôc v·ªÅ b√°c sƒ© ƒëi·ªÅu tr·ªã.\n");
        formatted.append("üìû **Kh·∫©n c·∫•p:** 0777815075");

        return formatted.toString();
    }

    private String tryOpenAIOrFallback(String message) {
        // Th·ª≠ OpenAI n·∫øu c√≥ key
        if (openaiApiKey != null && !openaiApiKey.trim().isEmpty() &&
                !openaiApiKey.equals("your-openai-api-key-here")) {
            try {
                return getOpenAIResponse(message);
            } catch (Exception e) {
                System.err.println("OpenAI API failed: " + e.getMessage());
            }
        }

        // Fallback v·ªÅ logic c·ª©ng
        return getSymptomAnalysis(message);
    }

    private String getOpenAIResponse(String message) {
        try {
            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("model", "gpt-3.5-turbo");

            List<Map<String, String>> messages = new ArrayList<>();

            Map<String, String> systemMessage = new HashMap<>();
            systemMessage.put("role", "system");
            systemMessage.put("content", createMedicalPrompt(message));

            Map<String, String> userMessage = new HashMap<>();
            userMessage.put("role", "user");
            userMessage.put("content", message);

            messages.add(systemMessage);
            messages.add(userMessage);

            requestBody.put("messages", messages);
            requestBody.put("max_tokens", 500);
            requestBody.put("temperature", 0.3);

            String response = webClient.post()
                    .uri("https://api.openai.com/v1/chat/completions")
                    .header("Authorization", "Bearer " + openaiApiKey)
                    .header("Content-Type", "application/json")
                    .bodyValue(requestBody)
                    .retrieve()
                    .bodyToMono(String.class)
                    .timeout(Duration.ofSeconds(30))
                    .block();

            JsonNode jsonResponse = objectMapper.readTree(response);
            String aiResponse = jsonResponse.get("choices").get(0).get("message").get("content").asText();
            return formatMedicalResponse(aiResponse);

        } catch (Exception e) {
            throw new RuntimeException("OpenAI Error: " + e.getMessage());
        }
    }

    // Gi·ªØ nguy√™n c√°c method c≈© cho fallback
    private Map<String, String> initializeSymptomDiagnosis() {
        Map<String, String> symptoms = new HashMap<>();

        // Tim m·∫°ch
        symptoms.put("ƒëau ng·ª±c", "üîç **ƒê√ÅNH GI√Å:** ACS, PE, Pneumothorax\nüìä **X√âT NGHI·ªÜM:** ECG, Troponin, D-dimer\nüè• **C·∫¶N KH√ÅM NGAY**");
        symptoms.put("kh√≥ th·ªü", "üîç **ƒê√ÅNH GI√Å:** Suy tim, PE, Pneumonia\nüìä **X√âT NGHI·ªÜM:** BNP, CXR, CTPA\n‚ö° **∆ØU TI√äN CAO**");
        symptoms.put("h·ªìi h·ªôp", "üîç **ƒê√ÅNH GI√Å:** Arrhythmia, Anxiety, Hyperthyroid\nüìä **X√âT NGHI·ªÜM:** ECG, TSH, Echo\nüü° **THEO D√ïI**");
        symptoms.put("ph√π ch√¢n", "üîç **ƒê√ÅNH GI√Å:** Suy tim, Suy th·∫≠n, DVT\nüìä **X√âT NGHI·ªÜM:** BNP, Creatinine, Doppler\nüü° **THEO D√ïI**");

        // H√¥ h·∫•p
        symptoms.put("ho khan", "üîç **ƒê√ÅNH GI√Å:** GERD, ACE-I, Asthma\nüìä **X√âT NGHI·ªÜM:** CXR, PPI trial\nüü¢ **TH·∫§P**");
        symptoms.put("ho c√≥ ƒë·ªùm", "üîç **ƒê√ÅNH GI√Å:** Pneumonia, Bronchitis, COPD\nüìä **X√âT NGHI·ªÜM:** CXR, Sputum culture, CRP\nüü° **THEO D√ïI**");
        symptoms.put("th·ªü kh√≤ kh√®", "üîç **ƒê√ÅNH GI√Å:** Asthma, COPD, CHF\nüìä **X√âT NGHI·ªÜM:** PFT, CXR, BNP\nüü° **THEO D·ªäI**");
        symptoms.put("th·ªü g·∫•p", "üîç **ƒê√ÅNH GI√Å:** PE, Pneumothorax, MI\nüìä **X√âT NGHI·ªÜM:** ABG, CTPA, ECG\nüî¥ **KH·∫®N C·∫§P**");
        symptoms.put("ho ra m√°u", "üîç **ƒê√ÅNH GI√Å:** TB, Cancer, PE, Bronchiectasis\nüìä **X√âT NGHI·ªÜM:** CT chest, AFB, Bronchoscopy\nüî¥ **KH·∫®N C·∫§P**");

        // Ti√™u h√≥a
        symptoms.put("ƒëau b·ª•ng", "üîç **ƒê√ÅNH GI√Å:** Appendicitis, Pancreatitis, Gallstones\nüìä **X√âT NGHI·ªÜM:** CT abdomen, Lipase, WBC\nüü° **THEO D√ïI**");
        symptoms.put("bu·ªìn n√¥n", "üîç **ƒê√ÅNH GI√Å:** Gastritis, Pancreatitis, Pregnancy\nüìä **X√âT NGHI·ªÜM:** Œ≤hCG, Lipase, H.pylori\nüü¢ **TH·∫§P**");
        symptoms.put("ti√™u ch·∫£y", "üîç **ƒê√ÅNH GI√Å:** Gastroenteritis, IBD, C.diff\nüìä **X√âT NGHI·ªÜM:** Stool culture, Calprotectin\nüü° **THEO D·ªöI**");
        symptoms.put("t√°o b√≥n", "üîç **ƒê√ÅNH GI√Å:** IBS, Medication, Diet\nüìä **X√âT NGHI·ªÜM:** Colonoscopy n·∫øu >50 tu·ªïi\nüü¢ **TH·∫§P**");
        symptoms.put("v√†ng da", "üîç **ƒê√ÅNH GI√Å:** Hepatitis, Gallstones, Hemolysis\nüìä **X√âT NGHI·ªÜM:** LFT, Bilirubin, MRCP\nüü° **THEO D√ïI**");

        // Th·∫ßn kinh
        symptoms.put("ƒëau ƒë·∫ßu", "üîç **ƒê√ÅNH GI√Å:** Migraine, Tension, SAH\nüìä **X√âT NGHI·ªÜM:** CT head n·∫øu red flags\nüü° **THEO D√ïI**");
        symptoms.put("ch√≥ng m·∫∑t", "üîç **ƒê√ÅNH GI√Å:** BPPV, Orthostatic, Stroke\nüìä **X√âT NGHI·ªÜM:** MRI n·∫øu focal signs\nüü° **THEO D√ïI**");
        symptoms.put("co gi·∫≠t", "üîç **ƒê√ÅNH GI√Å:** Epilepsy, Metabolic, Infection\nüìä **X√âT NGHI·ªÜM:** EEG, Glucose, CT head\nüî¥ **KH·∫®N C·∫§P**");
        symptoms.put("t√™ li·ªát", "üîç **ƒê√ÅNH GI√Å:** Stroke, Spinal compression\nüìä **X√âT NGHI·ªÜM:** CT/MRI brain/spine\nüî¥ **KH·∫®N C·∫§P**");
        symptoms.put("y·∫øu c∆°", "üîç **ƒê√ÅNH GI√Å:** Myopathy, Neuropathy, MG\nüìä **X√âT NGHI·ªÜM:** CK, EMG, AChR Ab\nüü° **THEO D√ïI**");

        // Kh√°c
        symptoms.put("s·ªët", "üîç **ƒê√ÅNH GI√Å:** Infection, Autoimmune, Malignancy\nüìä **X√âT NGHI·ªÜM:** CBC, Blood culture, CRP\nüü° **THEO D√ïI**");
        symptoms.put("s√∫t c√¢n", "üîç **ƒê√ÅNH GI√Å:** Cancer, Hyperthyroid, Depression\nüìä **X√âT NGHI·ªÜM:** CT chest/abdomen, TSH\nüü° **THEO D√ïI**");
        symptoms.put("m·ªát m·ªèi", "üîç **ƒê√ÅNH GI√Å:** Anemia, Thyroid, Depression\nüìä **X√âT NGHI·ªÜM:** CBC, TSH, Vitamin B12\nüü¢ **TH·∫§P**");

        return symptoms;
    }

    private Map<String, String> initializeDicomFindings() {
        Map<String, String> findings = new HashMap<>();

        // CT Chest patterns
        findings.put("ground glass", "ü´Å **Ground Glass Opacity:**\nCOVID-19, PCP, Drug toxicity\n**Ph√¢n b·ªë:** Peripheral (COVID), Central (PCP)");
        findings.put("consolidation", "ü´Å **Consolidation:**\nBacterial pneumonia, Aspiration\n**ƒê·∫∑c ƒëi·ªÉm:** Air bronchograms, lobar");
        findings.put("cavitary", "ü´Å **Cavitary lesion:**\nTB (upper lobe), Cancer (thick wall), Abscess\n**Wall >4mm:** Nghi ng·ªù malignancy");
        findings.put("honeycombing", "ü´Å **Honeycombing:**\nIPF, End-stage fibrosis\n**V·ªã tr√≠:** Subpleural, bilateral lower");
        findings.put("tree in bud", "ü´Å **Tree-in-bud:**\nInfection, Aspiration\n**Ph√¢n b·ªë:** Centrilobular nodules");
        findings.put("pneumothorax", "ü´Å **Pneumothorax:**\n>20% c·∫ßn chest tube\n**Tension:** Emergency decompression");
        findings.put("pleural effusion", "ü´Å **Pleural effusion:**\nHeart failure, Infection, Malignancy\n**Bilateral:** CHF. **Unilateral:** Infection/Cancer");
        findings.put("pulmonary embolism", "ü´Å **Pulmonary embolism:**\nFilling defect, RV strain\n**Massive:** Shock, thrombolysis");

        // CT Abdomen patterns
        findings.put("appendicitis", "ü´É **Appendicitis:**\nWall thickening >6mm, fat stranding\n**Perforated:** Free fluid, abscess");
        findings.put("pancreatitis", "ü´É **Pancreatitis:**\nPancreatic enlargement, fat stranding\n**Severe:** Necrosis, fluid collections");
        findings.put("gallstones", "ü´É **Gallstones:**\nHyperdense stones, wall thickening\n**Complications:** Cholangitis, pancreatitis");
        findings.put("bowel obstruction", "ü´É **Bowel obstruction:**\nDilated loops, air-fluid levels\n**Strangulation:** Ischemia, surgery");
        findings.put("free air", "ü´É **Pneumoperitoneum:**\nPerforated viscus\n**Emergency surgery** indicated");
        findings.put("liver lesion", "ü´É **Liver lesion:**\nHCC, Metastases, Hemangioma\n**Enhancement pattern** key");

        // CT Brain patterns
        findings.put("hypodense", "üß† **Hypodense lesion:**\nIschemic stroke, Edema, Tumor\n**Acute:** <6h invisible on CT");
        findings.put("hyperdense", "üß† **Hyperdense lesion:**\nAcute hemorrhage, Contrast\n**Subarachnoid:** Aneurysm rupture");
        findings.put("midline shift", "üß† **Midline shift:**\n>5mm significant mass effect\n**Neurosurgery consult** needed");
        findings.put("hydrocephalus", "üß† **Hydrocephalus:**\nVentricular enlargement\n**Acute:** Emergent shunt");

        return findings;
    }

    private String getSymptomAnalysis(String message) {
        String lowerMessage = message.toLowerCase().trim();
        List<String> foundSymptoms = new ArrayList<>();
        List<String> foundDicom = new ArrayList<>();

        // T√¨m tri·ªáu ch·ª©ng
        for (String symptom : symptomDiagnosis.keySet()) {
            if (lowerMessage.contains(symptom)) {
                foundSymptoms.add(symptom);
            }
        }

        // T√¨m DICOM findings
        for (String finding : dicomFindings.keySet()) {
            if (lowerMessage.contains(finding.replace(" ", "")) ||
                    lowerMessage.contains(finding)) {
                foundDicom.add(finding);
            }
        }

        StringBuilder response = new StringBuilder();

        if (!foundSymptoms.isEmpty()) {
            response.append("ü©∫ **PH√ÇN T√çCH TRI·ªÜU CH·ª®NG**\n\n");

            for (String symptom : foundSymptoms) {
                response.append("**").append(symptom.toUpperCase()).append(":**\n");
                response.append(symptomDiagnosis.get(symptom)).append("\n\n");
            }

            // Combination analysis
            if (foundSymptoms.size() > 1) {
                response.append("üîç **K·∫æT H·ª¢P TRI·ªÜU CH·ª®NG:**\n");
                response.append(analyzeCombination(foundSymptoms)).append("\n\n");
            }
        }

        if (!foundDicom.isEmpty()) {
            response.append("üì∏ **PH√ÇN T√çCH DICOM**\n\n");

            for (String finding : foundDicom) {
                response.append("**").append(finding.toUpperCase()).append(":**\n");
                response.append(dicomFindings.get(finding)).append("\n\n");
            }
        }

        if (foundSymptoms.isEmpty() && foundDicom.isEmpty()) {
            response.append("ü§ñ **T∆Ø V·∫§N Y T·∫æ AIDIMS**\n\n");
            response.append("Xin ch√†o! T√¥i l√† AI h·ªó tr·ª£ y t·∫ø. Vui l√≤ng m√¥ t·∫£ tri·ªáu ch·ª©ng c·ª• th·ªÉ.\n\n");
            response.append("**V√≠ d·ª•:**\n");
            response.append("üìû **Kh·∫©n c·∫•p:** 0777815075");
        }

        return response.toString();
    }

    private String analyzeCombination(List<String> symptoms) {
        // Common combinations
        if (symptoms.contains("ƒëau ng·ª±c") && symptoms.contains("kh√≥ th·ªü")) {
            return "‚ö° **ACS vs PE vs Pneumothorax**\nECG + Troponin + D-dimer + CTPA\nüî¥ **KH·∫®N C·∫§P**";
        }

        if (symptoms.contains("s·ªët") && symptoms.contains("ho c√≥ ƒë·ªùm")) {
            return "ü¶† **Pneumonia**\nCXR + Blood culture + CRP + PCT\nüü° **KH√ÅNG SINH**";
        }

        if (symptoms.contains("ƒëau b·ª•ng") && symptoms.contains("s·ªët")) {
            return "ü´É **Appendicitis vs Cholecystitis**\nCT abdomen + WBC + Lipase\nüî¥ **PH·∫™U THU·∫¨T?**";
        }

        if (symptoms.contains("ƒëau ƒë·∫ßu") && symptoms.contains("s·ªët")) {
            return "üß† **Meningitis vs SAH**\nCT head + LP + Blood culture\nüî¥ **KH·∫®N C·∫§P**";
        }

        if (symptoms.contains("kh√≥ th·ªü") && symptoms.contains("ph√π ch√¢n")) {
            return "üíß **Heart Failure**\nBNP + Echo + CXR\nüü° **NH·∫¨P VI·ªÜN**";
        }

        String combo = String.join(" + ", symptoms);
        return "üîç **ƒêa tri·ªáu ch·ª©ng:** " + combo + "\nüìã **C·∫ßn ƒë√°nh gi√° to√†n di·ªán**";
    }
    public String analyzeImages(ImageAnalysisRequest request) {
        if (geminiApiKey == null || geminiApiKey.trim().isEmpty() ||
                geminiApiKey.equals("YOUR_GEMINI_API_KEY_HERE")) {
            throw new RuntimeException("Gemini API key ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh");
        }

        try {
            // Create medical image analysis prompt
            String medicalPrompt = createMedicalImagePrompt(request.getMessage());

            // Create multimodal request body for Gemini Vision
            Map<String, Object> requestBody = createGeminiVisionRequestBody(medicalPrompt, request.getImages());

            // Call Gemini Vision API
            String response = webClient.post()
                    .uri(geminiVisionApiUrl + "?key=" + geminiApiKey)
                    .header("Content-Type", "application/json")
                    .bodyValue(requestBody)
                    .retrieve()
                    .bodyToMono(String.class)
                    .timeout(Duration.ofSeconds(45)) // Longer timeout for image analysis
                    .block();

            // Parse response
            JsonNode jsonResponse = objectMapper.readTree(response);

            if (jsonResponse.has("candidates") &&
                    jsonResponse.get("candidates").size() > 0) {

                JsonNode candidate = jsonResponse.get("candidates").get(0);
                if (candidate.has("content") &&
                        candidate.get("content").has("parts") &&
                        candidate.get("content").get("parts").size() > 0) {

                    String aiResponse = candidate.get("content").get("parts").get(0).get("text").asText();
                    return formatMedicalImageResponse(aiResponse, request.getImages().size());
                }
            }

            throw new RuntimeException("Invalid response format from Gemini Vision");

        } catch (WebClientResponseException e) {
            throw new RuntimeException("Gemini Vision API Error: " + e.getStatusCode() + " - " + e.getResponseBodyAsString());
        } catch (Exception e) {
            throw new RuntimeException("Gemini Vision API Error: " + e.getMessage());
        }
    }

    /**
     * T·∫°o request body cho Gemini Vision API v·ªõi text v√† images
     */
    private Map<String, Object> createGeminiVisionRequestBody(String prompt, List<ImageAnalysisRequest.ImageData> images) {
        Map<String, Object> requestBody = new HashMap<>();

        // Create parts array with text and images
        List<Map<String, Object>> parts = new ArrayList<>();

        // Add text part
        Map<String, Object> textPart = new HashMap<>();
        textPart.put("text", prompt);
        parts.add(textPart);

        // Add image parts
        for (ImageAnalysisRequest.ImageData image : images) {
            Map<String, Object> imagePart = new HashMap<>();
            Map<String, Object> inlineData = new HashMap<>();

            // Remove data URL prefix if present (data:image/jpeg;base64,)
            String base64Data = image.getData();
            if (base64Data.contains(",")) {
                base64Data = base64Data.split(",")[1];
            }

            inlineData.put("mime_type", image.getType());
            inlineData.put("data", base64Data);
            imagePart.put("inline_data", inlineData);
            parts.add(imagePart);
        }

        // Create content
        Map<String, Object> content = new HashMap<>();
        content.put("parts", parts);

        // Create contents array
        requestBody.put("contents", Arrays.asList(content));

        // Generation config for image analysis
        Map<String, Object> generationConfig = new HashMap<>();
        generationConfig.put("temperature", 0.2); // Lower temperature for medical analysis
        generationConfig.put("topK", 32);
        generationConfig.put("topP", 0.9);
        generationConfig.put("maxOutputTokens", 2048); // More tokens for detailed analysis

        requestBody.put("generationConfig", generationConfig);

        // Safety settings
        List<Map<String, Object>> safetySettings = new ArrayList<>();
        String[] categories = {
                "HARM_CATEGORY_HARASSMENT",
                "HARM_CATEGORY_HATE_SPEECH",
                "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "HARM_CATEGORY_DANGEROUS_CONTENT"
        };

        for (String category : categories) {
            Map<String, Object> safety = new HashMap<>();
            safety.put("category", category);
            safety.put("threshold", "BLOCK_ONLY_HIGH");
            safetySettings.add(safety);
        }

        requestBody.put("safetySettings", safetySettings);

        return requestBody;
    }

    /**
     * T·∫°o prompt chuy√™n d·ª•ng cho ph√¢n t√≠ch h√¨nh ·∫£nh y t·∫ø
     */
    private String createMedicalImagePrompt(String userMessage) {
        return "B·∫°n l√† AI chuy√™n gia ph√¢n t√≠ch h√¨nh ·∫£nh y t·∫ø c·ªßa b·ªánh vi·ªán AIDIMS.\n\n" +
                "NHI·ªÜM V·ª§ PH√ÇN T√çCH H√åNH ·∫¢NH Y T·∫æ:\n" +
                "- M√¥ t·∫£ chi ti·∫øt nh·ªØng g√¨ nh√¨n th·∫•y trong h√¨nh ·∫£nh\n" +
                "- X√°c ƒë·ªãnh lo·∫°i h√¨nh ·∫£nh y t·∫ø (X-quang, CT, MRI, si√™u √¢m, etc.)\n" +
                "- Ph√¢n t√≠ch c√°c c·∫•u tr√∫c gi·∫£i ph·∫´u b√¨nh th∆∞·ªùng\n" +
                "- Ch·ªâ ra c√°c b·∫•t th∆∞·ªùng n·∫øu c√≥\n" +
                "- ƒê∆∞a ra ch·∫©n ƒëo√°n ph√¢n bi·ªát d·ª±a tr√™n h√¨nh ·∫£nh\n" +
                "- ƒê·ªÅ xu·∫•t th√™m x√©t nghi·ªám n·∫øu c·∫ßn\n\n" +

                "ƒê·ªäNH D·∫†NG TR·∫¢ L·ªúI:\n" +
                "üì∏ **LO·∫†I H√åNH ·∫¢NH:** [X-quang/CT/MRI/etc.]\n\n" +

                "üîç **M√î T·∫¢ H√åNH ·∫¢NH:**\n" +
                "- V√πng ch·ª•p: [...]\n" +
                "- T∆∞ th·∫ø: [...]\n" +
                "- Ch·∫•t l∆∞·ª£ng ·∫£nh: [...]\n\n" +

                "‚úÖ **C·∫§U TR√öC B√åNH TH∆Ø·ªúNG:**\n" +
                "- [...]\n" +
                "- [...]\n\n" +

                "‚ö†Ô∏è **PH√ÅT HI·ªÜN B·∫§T TH∆Ø·ªúNG:**\n" +
                "- [...]\n" +
                "- [...]\n\n" +

                "ü©∫ **CH·∫®N ƒêO√ÅN PH√ÇN BI·ªÜT:**\n" +
                "1. [Ch·∫©n ƒëo√°n ch√≠nh] - [ƒë·ªô tin c·∫≠y]\n" +
                "2. [Ch·∫©n ƒëo√°n 2] - [ƒë·ªô tin c·∫≠y]\n" +
                "3. [Ch·∫©n ƒëo√°n 3] - [ƒë·ªô tin c·∫≠y]\n\n" +

                "üìä **ƒê·ªÄ XU·∫§T TH√äM:**\n" +
                "- X√©t nghi·ªám: [...]\n" +
                "- H√¨nh ·∫£nh b·ªï sung: [...]\n" +
                "- T∆∞ v·∫•n chuy√™n khoa: [...]\n\n" +

                "‚ö° **M·ª®C ƒê·ªò ∆ØU TI√äN:**\n" +
                "üî¥ Kh·∫©n c·∫•p / üü° Theo d√µi / üü¢ B√¨nh th∆∞·ªùng\n\n" +

                "L∆ØU √ù QUAN TR·ªåNG:\n" +
                "- Ph√¢n t√≠ch kh√°ch quan d·ª±a tr√™n h√¨nh ·∫£nh\n" +
                "- Kh√¥ng ƒë∆∞a ra ch·∫©n ƒëo√°n ch·∫Øc ch·∫Øn\n" +
                "- Lu√¥n khuy·∫øn c√°o tham kh·∫£o b√°c sƒ© chuy√™n khoa\n" +
                "- Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, r√µ r√†ng, d·ªÖ hi·ªÉu\n\n" +

                "C√ÇU H·ªéI C·ª¶A NG∆Ø·ªúI D√ôNG:\n" + (userMessage != null ? userMessage : "Ph√¢n t√≠ch h√¨nh ·∫£nh y t·∫ø n√†y");
    }

    /**
     * Format response cho ph√¢n t√≠ch h√¨nh ·∫£nh y t·∫ø
     */
    private String formatMedicalImageResponse(String response, int imageCount) {
        StringBuilder formatted = new StringBuilder();

        // Add header
        formatted.append("üî¨ **K·∫æT QU·∫¢ PH√ÇN T√çCH H√åNH ·∫¢NH Y T·∫æ**\n");
        formatted.append("üìä *ƒê√£ ph√¢n t√≠ch ").append(imageCount).append(" h√¨nh ·∫£nh*\n\n");

        formatted.append(response);

        // Add important disclaimers
        formatted.append("\n\n---\n");
        formatted.append("‚ö†Ô∏è **QUAN TR·ªåNG:**\n");
        formatted.append("‚Ä¢ ƒê√¢y ch·ªâ l√† h·ªó tr·ª£ ph√¢n t√≠ch s∆° b·ªô\n");
        formatted.append("‚Ä¢ Quy·∫øt ƒë·ªãnh ch·∫©n ƒëo√°n cu·ªëi c√πng thu·ªôc v·ªÅ b√°c sƒ© chuy√™n khoa\n");
        formatted.append("‚Ä¢ C·∫ßn k·∫øt h·ª£p v·ªõi tri·ªáu ch·ª©ng l√¢m s√†ng v√† ti·ªÅn s·ª≠ b·ªánh\n");
        formatted.append("‚Ä¢ N·∫øu c√≥ tri·ªáu ch·ª©ng nghi√™m tr·ªçng, h√£y ƒë·∫øn b·ªánh vi·ªán ngay\n\n");
        formatted.append("üìû **Kh·∫©n c·∫•p:** 0777815075\n");
        formatted.append("üè• **B·ªánh vi·ªán AIDIMS** - Chuy√™n khoa Ch·∫©n ƒëo√°n H√¨nh ·∫£nh");

        return formatted.toString();
    }
}
